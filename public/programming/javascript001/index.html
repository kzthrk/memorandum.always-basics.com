<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.64.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>JavaScriptでループの同期処理&nbsp;&ndash;&nbsp;Memorandum - Danger past, got forgotten</title><link rel="stylesheet" href="/css/core.min.2afffb91c470e0193a6e12fd02ba70b078d207aa384789ec7b39a3f263595710fa0d1e1373f3f3988a8a1663ee51d7f6.css" integrity="sha384-Kv/7kcRw4Bk6bhL9ArpwsHjSB6o4R4nsezmj8mNZVxD6DR4Tc/PzmIqKFmPuUdf2"><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/images/logo.jpg" alt /><span class="site name">Memorandum - Danger past, got forgotten</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a></nav></div></span></div><div class="site slogan"><span class="title">継続する秘訣は、途切れたと思った時に、もう一度だけ繰り返すこと</span></div></section><div id="content"><section class="article header">
    <h1 class="article title">JavaScriptでループの同期処理</h1><p class="article date">Thursday, February 6, 2020</p></section><article class="article markdown-body"><h1 id="はじめに">はじめに</h1>
<p>JavaScriptを使い慣れていないと、
非同期処理をループで回して、終わりを待ちたい</p>
<p>複数行で言うと
題材は何でも良いのですが、ここではデータベースのTable_A, Table_B, Table_Cのレコード数を取り出し、その和(10+20+30=60)を求めたいとします。</p>
<p>let sum = 0
for (const label in [&ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;]) {</p>
<pre><code>sum += select count(*)してくれる関数(&quot;Table_&quot; + label)
</code></pre>
<p>}
console.log(sum)
この例はおそらくsumが0として残念な結果になると思います。 で、この記事を読む動機を持った方は、大げさに言うと下のようなことになりたくないといった感じでしょうか。</p>
<p>count(&ldquo;Table_A&rdquo;).then(result =&gt; {
sum += result
count(&ldquo;Table_B&rdquo;).then(result =&gt; {
sum += result
count(&ldquo;Table_C&rdquo;).then(result =&gt; {
sum += result
console.log(sum)
}
}
}
ここまでひどくは無くても、then.then.then　と君の名は。状態は避けたいと。そして、ループで処理したいよねと。 それをここでは扱います。</p>
<p>なので
ここまででお分かりの方には「同期処理」や「同期実行」という話題は扱わないというのがお分かりかと思いますが 私含めて、この「やりたいこと」を考えているときには、自分の考えていることと検索キーワードの不一致に気がついて いなかったので、あえてこう書きました。</p>
<p>実食
使うのはPrpmise.all()です。</p>
<p>これまで「なにそれおいしいの？」と思っていた方、「なんだかよくわかんねーな」と思っていた方、意味分からなくてもこのひな形をコピペすれば、一応終了待ちは出来ますので是非。</p>
<p>意味分からなくてもスイッチ押せばエンジンはかかるんですよ。え、なに？お宅のはモーターだって？大丈夫、ちゃんとエンジンブレーキもききますって。ま、あとは、勉強するなり、実験するなり、意味が分からないまま使い続けるなり、お好きにすれば良いと思います。でもボタン押さないのはもったいない。</p>
<p>Promise.all()
ここでは、DBアクセスの代わりにsetTimeout()を使っています。</p>
<p>let sum = 0</p>
<p>const test = function(param) {
return new Promise( function(resolve, reject) {
setTimeout(function(){
sum += param
resolve(sum)
}, param*1000)
})
}</p>
<p>const promises = []
promises.push(test(3))
promises.push(test(5))</p>
<p>Promise.all(promises).then(function(result) {
console.log(&ldquo;result: &quot; + JSON.stringify(result))
console.log(&ldquo;sum: &quot; + sum)
}).catch(err =&gt; {
console.log(&ldquo;err: &quot; + JSON.stringify(err))
})
console.log(&ldquo;sum: &quot; + sum)
これで無事に、合計値が得られます</p>
<p>sum: 0
result: [3,8]
sum: 8
やりたいことをsetTimeout()の箇所に記載すればいいわけです。</p>
<p>補足
Promise.all()は処理の合流
Promise.all()は同期的に実行しているわけではありません。あくまで終了待ち、処理を合流させるために使うものです。 そして、それは指定した処理だけの話です。次のコードを実行すればそれが分かります。</p>
<p>console.log(&ldquo;begin&rdquo;)
let sum = 0</p>
<p>const test = function(param) {
console.log(&ldquo;2 &quot; + param + &ldquo;秒&rdquo;)
return new Promise( function(resolve, reject) {
console.log(&ldquo;3&rdquo;)
setTimeout(function(){
console.log(&ldquo;5 &quot; + param + &ldquo;秒待ち&rdquo;)
sum += param
resolve(sum)
}, param*1000)
console.log(&ldquo;4&rdquo;)
})
}</p>
<p>console.log(&ldquo;1&rdquo;)
const promises = []
promises.push(test(3))
console.log(&ldquo;6.1: sum: &quot; + sum)
promises.push(test(5))</p>
<p>setTimeout(function() {
console.log(&ldquo;6.2: sum: &quot; + sum)
}, 6000)</p>
<p>setTimeout(function() {</p>
<p>console.log(&ldquo;7&rdquo;)
Promise.all(promises).then(function(result) {
console.log(&ldquo;8.1: result: &quot; + JSON.stringify(result))
console.log(&ldquo;8.1: sum: &quot; + sum)
}).catch(err =&gt; {
console.log(&ldquo;8.2: err: &quot; + JSON.stringify(err))
})
}, 7000)</p>
<p>console.log(&ldquo;end&rdquo;)
結果</p>
<p>begin
1
2 3秒
3
4
6.1: sum: 0
2 5秒
3
4
end
5 3秒待ち
5 5秒待ち
6.2: sum: 8
7
8.1: result: [3,8]
8.1: sum: 8
考えてみれば当たり前ですが、二つの処理はpromisesにpush()された行で動き始めるので、5.x秒後には終わっているはずです。 なので、6秒後に結果を確認すると結果は出そろっています。このコードでは「合流して確認」という作業を7秒後に発動させているだけです。 Primise.all()を使うと、この5.x秒とかを意識せずに、すでに終わっていようが終わっていまいが、合流後の処理を記載できるということに過ぎません。 そして、このPromise.all()を囲っているsetTimeout()を外すと次の結果となり、Promise.all()自体も非同期処理としてその先に進んでしまっているので、ここで全体が待ってくれているわけではありません。</p>
<p>begin
1
2 3秒
3
4
6.1: sum: 0
2 5秒
3
4
7
end
5 3秒待ち
5 5秒待ち
8.1: result: [3,8]
8.1: sum: 8
6.2: sum: 8
JavaやC++の類いでもスレッドの扱いで面倒があったかと思いますが。ただ世界をひっくり返しただけなので別に楽も苦労もしていません。隣の芝、青かった？使用人の皆さん、よくおっしゃるんですよねー。</p>
</article><section class="article labels"><a class="category" href=/categories/programming/>Programming</a><a class="tag" href=/tags/javascript/>JavaScript</a><a class="tag" href=/tags/%E5%90%8C%E6%9C%9F/>同期</a></section></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Always Basics.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section><script src="/js/hljs.min.0799348a91dce12c6be4a73f943cfe78f181f4e6f6ec35c4af0fca1de377879f77cfab03c30f03a174d675737b5a9314.js" integrity="sha384-B5k0ipHc4Sxr5Kc/lDz&#43;ePGB9Ob27DXErw/KHeN3h593z6sDww8DoXTWdXN7WpMU"></script><script>hljs.initHighlightingOnLoad();</script></div>
</body>

</html>